# Реферат
## по курсу "Логическое программирование"

### студент: Ли А.И.

## ТЕМА "Как научить младшую сестру/брата логическому программированию"

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

Возможно ли научить ребенка логическому программированию? И если ответ положительный, то как это сделать? 
Пожалуй, начать стоит с того, что ребенок должен достичь определенного возраста и иметь определенные навыки для того, чтобы не было необходимости объяснять ему совсем базовые вещи, которые могут не относиться к процессу обучения логическому программированию. Иными словами, ребенку нужно знать основы элементарной математики и логики. Конечно, это может быть и не обязательным условием, если преподаватель является опытным и хорошо знающим свое ремесло учителем. Но так как в данной роли выступать буду я, студентка второго курса Московского Авиационного Института, не имеющая большого опыта в преподавании и в общении с детьми, а также не изучающая логическое программирование углубленно, то обучение данному предмету может сильно затянуться и стать каторгой как для ребенка, так и для меня самой. И для более простого процесса обучения возьмем среднестатистического ребенка одиннадцати лет, учащегося пятого класса средней школы. 

## Что такое программирование?

Скорее всего ребенок, которого мы собираемся обучить логическому программированию, либо совсем не знает, что такое программирование, либо знает о нем, но очень поверхностно. Именно по этой причине начать нужно с объяснения о том, что из себя представляет программирование в целом.
Программированием называется составление компьютерной программы, которая основывается на некоем алгоритме. Оно условно делится на несколько групп (парадигм):  
•	Объектно-ориентированное: самый популярный и используемый вид программирования. Задача представляется в виде объектов, которые в свою очередь обладают свойствами и методами.  
•	Структурное: программа представлена в виде иерархических блоков, сами они друг от друга изолированы. Сама она состоит из основных структур, которые являются базовыми и управляющими: цикл, ветвление, подпрограммы.  
•	Функциональное: основным и базовым элементом программы является функция, ее задача также формулируется в виде функции.  
•	Логическое: задача с помощью проверки фактов, на ее основе выводится информация.

Итак, в общих совах мы смогли объяснить ребенку, что такое программирование и на какие группы оно делится. Далее нам понадобится углубиться в понятие логического программирования.

## Логическое программирование

Прежде всего начинать обучение любому предмету необходимо с четкого объяснения того, что конкретно изучается и зачем. То есть нужно дать максимально понятное и простое определение предмета, которому человек собирается обучать. В нашем случае этим предметом является логическое программирование. Так что же это такое? И с чем его «едят»?
Объясняя простым языком, логическое программирование изучает факты и на основе их изучения выдает конечную информацию. Для еще более легкого понимания, а ведь мы пытаемся объяснить не самые простые вещи десятилетнему ребенку, можно сравнить данный язык с процессом обучения маленького ребенка тому, что можно делать, а что нельзя. В результате нашего разделения предметов на доступные и недоступные, ребенок изучает мир и предметы (факты) в нем, обрабатывает данные и сопоставляет их с нашими наставлениями, и принимает определенные решения (делает вывод информации). 

##  Структура программы

Любая программа, написанная на языке логического программирования (в нашем случае для обучения мы возьмем Prolog, о котором расскажем позже), должна состоять из предикатов, которые представляют из себя функции с логическими значениями, все предикаты содержат в себе определенные вычисления, являющиеся истинными или ложными. Однако предикат возвращает результат только в том случае, если вычисления являются истиной. Составляющими самих предикатов является набор правил (предложений), которые описывают вычисления. Между собой они соединены логическими операторами и/или (запятая соответствует оператору «и», а точка – «или»).

Пример 1.

```
I:
studied(alice, english).
studied(alice, mathematics).
studied(alice, IT).
studied(alex, french).
studied(alice, literature).

II:
studied_technical :- studied(Y, mathematics).
studied_technical :- studied(Y, informatics).

studied_language :- studied(Y, english).
studied_language :- studied(Y, french).

speciality(Y, porgrammer) :- studied(Y, mathematics), studied(Y, informatics).
speciality(Y, tech_translator) :- studied_language(Y), studied_technical(Y).
```

В данном примере мы рассматриваем некую базу данных, в которой содержится список студентов и предметы, которые они изучают, и предикаты определения конечной специализации студентов. В первой части программы (I) мы видим набор фактов, иными словами набор сведений о студенте. Studied – предикат, который содержит факт того, что студент изучает определенный предмет; alice, alex, french и т.д. – константы (или атомы), которые ставятся в соответствие объектам предметной области. Также обязательно стоит упомянуть о том, что имена должны записываться со строчной буквы, так как они являются идентификаторами, в противном случае, если не соблюдать данное правило, интерпретатор будет трактовать Alice не как идентификатор, а как переменную. В блоке II содержатся правила, благодаря которым делаются логические выводы, основывающиеся на фактах. Последняя строчка означает, что специализацией некоторого студента Y является специализация технический переводчик, если этот студент изучал технические предметы и иностранные языки. Знак :- можно рассматривать как «если».
Подводя итог, мы можем сделать вывод, что программа на языке логического программирования базируется на своде фактов и правил, а далее уже помещаются в базу фактов и правил. 
Также очень удобно представить запрос в виде дерева. Данный совет позволит упростить понимание программы. Такое представление запроса особенно сильно может помочь в процессе объяснения принципа действия задачи ребенку, так как дети легче всего воспринимают информацию в графическом виде. Но не стоит пренебрегать этим методом и взрослым людям.
Чтобы выполнить программу на Prolog, необходимо сделать запрос, который в свою очередь проверит выводимость утверждения из фактов и правил, содержащихся в программе. 

## Языки логического программирования

### Prolog
Теперь после того, как мы смогли объяснить ребенку, что такое логическое программирование, какие оно содержит правила и принципы и как работает (во всяком случае будем на это надеяться), стоит погрузиться в мир конкретного логического языка. И начнем мы с небольшого экскурса в историю и краткого определения языка. Сейчас я буду излагать сухие факты, но объясняя это ребенку, постараюсь дополнить свой рассказ картинками и интересными фактами, а также постараюсь описывать все красочно, активно жестикулируя и как можно больше вовлекая в разговор ребенка. 
Итак, как мы уже говорили ранее, Пролог является языком логического программирования, который основывается на предикатах математической логики. Сам по себе он сосредотачивается на определенных механизмах, таких как древовидное представление структур данных, сопоставление с образцом и автоматический перебор с возвратами. Он является декларативным языком, то есть правила и факты являются представлением логики программы, а сама логика уже выражается в виде терминов отношений. Пролог также используется в разработке и изучении искусственного интеллекта, компьютерной лингвистики и в целом нечислового программирования.
Свое начало Пролог берет в 1970-е годах. Разработан он был в 1972 Аленом Колмероэ. Его созданию послужила довольно бурно и активно развивающаяся в 1960-е годы теория автоматического доказательства теорем. Робинсон предложил алгоритм резолюций, позволяющий за конечное время доказать верную теорему. Данный алгоритм представляет собой обход графа в ширину, что, к сожалению, сводит предсказуемость его работы практически к 0, а такой подход, естественно, не подходит для любого языка программирования. Колмероэ же смог найти сужение задачи, то есть в итоге доказательство некоторых теорем могло выглядеть как процедурное исполнение программы. 
Непосредственный интерес к данному языку программирования имел скачкообразный вид: он то бурно развивался, то стихал на продолжительное время, то сменялся на неприятие. Самое большое внимание было приковано к нему в 1980-х годах, когда в Японии проводились национальные разработки компьютеров пятого поколения. Тогда Пролог рассматривался как язык будущего, разработчики надеялись, что с его помощью станет возможным создать абсолютно новые принципы, которые в будущем позволят компьютерам выйти на новый уровень искусственного интеллекта. Он также был включен в некоторые учебники информатики в советских вузах и школах. 
Код, написанный на Прологе, легко читается и воспринимается, в отличие от тех же объектно-ориентированных языков программирования (например, C++). Писать на Прологе можно и без вычислений, оперируя только фактами и выражениями. Он продолжает развиваться в ряде определенных стран, начинает вбирать в себя различные концепции и технологии, включая парадигмы императивного программирования. Но, конечно, в нем также есть и ряд минусов: непопулярность языка, а следовательно слабые инвестиции в него, и огромная сложность вычислительных операций. 

### Mercury
Говоря о языках логического программирования, нельзя не упомянуть о таком языке, как Mercury. Это язык нового поколения, который был создан с целью решить две проблемы Пролога, которые так или иначе возникают у пользователя при его использовании.
1.	Во-первых, у Пролога существует проблема отладки. К сожалению, компиляторы языков логического программирования делают намного меньше проверок, чем те же компиляторы языков императивного типа. Это вызывает сложности при нахождении ошибок, ведь пользователю приходится находить их самостоятельно и практически без какой-либо помощи отладчика. Подобная проблема вызывает значительные трудности при работе и занимает много времени, а в нынешние времена это является непозволительной роскошью. 
2.	Во-вторых, также очень существенной и важной является проблема производительности Пролога. Современные виды языков логического программирования сильно уступают по данному критерию языкам императивного типа. И опять же время сейчас является очень ценным ресурсом. Все программы и их отладка направлены на то, чтобы сократить то количество времени, за которое они выполняют свою задачу.
Сам Mercury был разработан в Мельбурнском университете, первая его версия была выпущена 8 апреля 1995 года.
Синтаксис данного языка много унаследовал от Пролога, поэтому, если вы знаете Пролог, то разобраться в Mercury для вас не станет непосильной и сложной задачей. Разработчики Mercury представляют его как надежный язык для разработки, уверяя пользователей в том, что если программа на нем скомпилировалась, то почти со 100% вероятностью она будет работать правильно.

## Синтаксис Prolog. Теория

Итак, как мы уже упоминали ранее, решение задачи на Прологе таково: структура программы состоит из описания фактов, правил и запросов. Сама программа включает в себя множество объектов, однако основными из них являются термы. Термы могут делится на простые и структурные, простые делятся на константы и перемены, а уже сами константы на атомы и числа.
Итак, что же такое атомы? Атомы – самая простая составляющая программы, то есть это константы, которые соответствуют объектам той предметной области, что описываются программой. Если атомы задаются одним и тем же идентификатором, то в течение всей программы они обозначают один и тот же объект.
Так как же может представляться атом синтаксически? Для этого существует несколько способов: 
1.	Последовательность спецсимволов (к примеру, <=).
2.	Последовательность спецсимволов, которые начинаются со строчной буквы (как пример, kojima). 
3.	Произвольная последовательность символов, которая заключена в апострофы (‘Hideo Kojima’).
Числа могут похвастаться только тем, что мало чем отличаются от атомов, однако они имеют возможность входить в арифметические выражения, а для них в Прологе предусмотрены специальные встроенные предикаты. 
Что можно сказать насчет переменных? Они должны записываться в виде идентификаторов, которые обязательно начинаются либо с заглавной буквы, либо с нижнего подчеркивания, как пример, Y, Kojima. Областью действия переменной являются какое-то одно правило, где она встречается, поэтому если мы видим две одинаковые переменные, которые встречаются в разных правилах, мы должны понимать, что они могут обозначать совершенно разные объекты. Однако важно знать, что интерпретатор Пролога не запоминает информацию об именах переменных, вместо этого он заменяет их ссылками. Стоит также упомянуть об анонимной переменной, которая обозначается одним знаком нижнего подчеркивания. Каждое ее вхождение обозначает новую переменную, то есть все ее вхождения в одно высказывание являются независимыми. Использовать анонимную переменную удобно тогда, когда ее значение больше не фигурирует в правиле, соответственно и нас более не интересует. Любая переменная в каждый момент времени является либо свободной, либо связанной. То есть переменная получает значение (связывается) посредством унификации, а изменить его можно только откатом назад, а не повторной унификацией. 
Структурные термы обычно используют в тех случаях, когда необходимо представить сложную структуру данных. В пример можно привести факт, который устанавливает дату рождения Хидео Кодзимы:  
born(‘Hideo Kojima’,date(24,august,1963)).  
Также очень важно поговорить о встроенных предикатах. В Прологе существуют такие встроенные предикаты, как true и fail, ввод-вывод. 
Простейшими из них, конечно, являются true и fail. Они всегда являются успешно доказуемыми или недоказуемыми. К примеру, true аналогично тождественно истинному высказыванию (20 = 20), а fail – тождественно ложному (12 = 3). 
Для императивных языков понятие ввода-вывода является очень важным, можно даже сказать основополагающим и базовым понятием. Почему? Все потому, что данное понятие позволяет разрабатывать массовые алгоритмы обработки информации, которые поступают на вход программе и выдают результат на выходе. Классические языки программирования не так зависимы от понятия ввода-вывода, так как его функции на себя берет интерпретатор. 
В Прологе существует несколько основных предикатов ввода-вывода:  
•	write(Y), который осуществляет вывод соответствующего значения Y в стандартный вывод  
•	read(Y) осуществляет ввод терм со стандартного ввода (при этом терм заканчивается точкой) и производит унификацию его с Y  
•	nl осуществляет печать символа перевода на новую строку (newline) . 
Приведем простой пример фрагмента кода: 
```
main :- speciality(alisa,Y),
write(Y), nl, fail.
```
В данном примере предикат speciality генерирует несколько решений, для каждого из них будет выполнен предикат write, который печатает соответствующее решение, а после этого будет инициирован возврат и поиск новых решений с помощью предиката fail.
Существует также определенный список предикатов для ввода-вывода из произвольных файлов:  
•	see(filename), который делает файл с указанными в скобках именем текущим для ввода   
•	tell(filename) является аналогичным с see, однако открывает указанный в скобках файл на запись   
•	seeing(filename), telling(filename) делают проверку на совпадение текущего файла, который используется для ввода и вывода, с указанным в скобках

## Синтаксис Mercury. Теория

Как уже говорилось ранее, Mercury был создан для решения некоторых проблем Пролога, следовательно он является по отношению к нему языком следующего поколения. Он является более типизированным и содержит различные атрибуты современной системы программирования, что делает его более коммерчески выгодным. И именно строгая типизация позволяет компилятору исключить значительное количество ошибок.
На Mercury возможно создание многомодульных программ. Приведем основные элементы:  
•	Заголовок модуля.  
•	Интерфейсная часть модуля, содержащая в себе описание всех объектов, которые экспортируются модулем.  
•	Реализационная часть модуля, содержащая в себе реализации всех необходимых предикатов.  
•	Импорт модулей.  

## План обучения

Как уже говорилось ранее, человеку без опыта преподавания и общения с детьми очень сложно будет обучить ребенка чему-то. Однако нельзя сказать, что это невозможно, самое главное грамотно составить план обучения, структурировать информацию и правильно ее преподнести, ведь самое главное помнить о том, что обучать придется именно ребенка, а не взрослого человека или хотя бы подростка. Именно из-за того важно постараться не излагать исключительно сухие факты. Вот небольшой набросок плана, которым можно пользоваться при попытках обучения:
1.	Постараться красочно объяснить ребенку, чем интересно программирование. Не говорить о его пользе в будущем, а именно заинтересовать. Для этого можно сделать небольшое видео или презентацию, а также важно самому быть увлеченным данным предметом. Можно объяснить, что благодаря логическому программированию можно лучше изучить окружающий мир, узнать что-то новое и интересное о предметах и явлениях, которые уже являются для всех обыденностью.
2.	Важно дать определение тому, что такое программирование в целом, особенно если ребенок не знает об этом ничего. Опять же весь процесс объяснения должен сопровождаться каким-либо визуальным рядом. 
3.	Далее необходимо углубиться конкретно в логическое программирование: рассказать о его принципах, структуре программ, углубиться в историю и синтаксис конкретных языков (в нашем случае это языки Prolog и частично Mercury). 
4.	Нужно показать несколько элементарных примеров программ, чтобы ребенок имел дело не только с теорией. А после освоения теоретической базы, дать ему самому написать самую простенькую программу. В процессе написания важно быть рядом, давать подсказки, наводящие вопросы и, в случае если ребенок совсем застопорился, еще раз кратко объяснить то, что он не понимает. 
5.	Очень важно запастись терпением! Процесс обучения – очень нелегкая задача, на ее решение тратится немало ресурсов. Главное не торопиться, постепенно и порционно давать ребенку новую информацию, а также не забывать хвалить его за успехи. 

## Заключение

Итак, в заключение хотелось бы отметить, что, прежде чем начать обучать кого-то какому-либо предмету, важно для начала самому углубиться в него и постараться понять со всех сторон. А если приходится учить ребенка, то стоит приложить вдвойне больше усилий, так как всегда нужно помнить, что дети воспринимают информацию иначе, чем взрослые. Самым главным критерием является их заинтересованность в процессе обучения, а этого можно добиться только в том случае, если вы сами заинтересованы в предмете и можете правильно его преподнести. Конкретно в моем случае ребенок, возможно, в полной мере и не познает все прелести логического программирования, однако будет знать элементарные вещи, базу. Для десятилетнего ребенка это будет уже явным прогрессом, а для меня, человека, который имеет невыносимо мало опыта в общении с детьми и тем более в их обучении, это будет счастьем. С таким фундаментом в будущем ребенок сможет и самостоятельно изучить данный предмет, а также лучше поймет, как описывать то, что его окружает. Он также немного узнает о программировании в целом и сможет улучшить свои навыки в логике, ведь изучение логического программирования не может пройти без последствий. Естественно, хороших.

## Список используемых источников

1.	Д. В. Сошников. Парадигма логического программирования – М.: «Вузовская книга», 2006. – 220 с.: ил.
2.  У. Клоксин, К.Меллиш, Программирование на языке Пролог.
3.	Введение в логическое программирование (Prolog) – Электронные текстовые дан. – Режим доступа: https://pro-prof.com/archives/2362
4.	Логическое программирование – Электронные текстовые дан. – Режим доступа: http://www.tadviser.ru/index.php/Статья:Логическое_программирование
5.	Парадигма: логическая – Электронные текстовые дан. – Режим доступа: http://progopedia.ru/paradigm/logic/
6.	Тип программирования – Электронные текстовые дан. – Режим доступа: https://geekbrains.ru/posts/programming_types
